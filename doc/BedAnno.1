.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "..::lib::BedAnno 3"
.TH ..::lib::BedAnno 3 "2021-02-25" "perl v5.28.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
BedAnno \- Perl module for annotating variation depend on the BED format database.
.SS "\s-1VERSION\s0 v1.30"
.IX Subsection "VERSION v1.30"
From version 0.32 BedAnno will change to support \s-1CG\s0's variant shell list
and use ncbi annotation release 104 as the annotation database
with reformatted database format, and won't give any individual
annotation, so the \fBindividual_anno()\fR is no longer available.
\&\s-1VCF4.1\s0 format variant description (chr, pos, ref, alt) will also
be supported.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use BedAnno;
\&  my $beda = BedAnno\->new( db => "in.bed.gz", tr => \*(Aqin.trans.fas\*(Aq );
\&  my $anno = $beda\->anno( \*(Aqchr20\*(Aq, 1234567, 1234569, \*(AqAG\*(Aq, \*(AqTGGG\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By using this module, we can get variants from whole-genome or exome-capture 
\&\s-1NGS\s0 genotyping result annotated. The information contains various possible 
\&\s-1HGVS\s0 string together with a most recent strandard \s-1HGVS\s0 mutation name. 
It can not annotate ambiguous variants (transition, transvertion, or unknown 
break point large deletion and duplication).
.PP
\&\fIBedAnno\fR annotate genomics variations of hg19 by using a \s-1BED\s0 format database, 
which construct from ncbi anno release 104, combined with tabix index.
This module can directly parse the vcf4.1 format ref and single alt string(no commas in it),
without normalized by vcftools, and can recognize the tandom repeat 
variation and duplication, generate the standard \s-1HGVS\s0 strings for 
most of complex cases. Also it will ajust the strand of transcript,
and follow the 3' nearest rules to annotate.
.SH "Methods"
.IX Header "Methods"
.SS "new"
.IX Subsection "new"
.IP "About : Creat a new annotation entry" 4
.IX Item "About : Creat a new annotation entry"
.PD 0
.IP "Usage :" 4
.IX Item "Usage :"
.PD
.Vb 1
\&    my $beda = BedAnno\->new( db => "in.bed.gz", tr => \*(Aqin.trans.fas.gz\*(Aq, batch => 1 );
.Ve
.IP "Args    \- (all database files should be tabix indexed)" 4
.IX Item "Args - (all database files should be tabix indexed)"
.RS 4
.PD 0
.IP "Essential Args:" 4
.IX Item "Essential Args:"
.RS 4
.IP "\fIdb\fR <in.bed.gz>" 4
.IX Item "db <in.bed.gz>"
.RS 4
.IP "annotation database file." 4
.IX Item "annotation database file."
.RE
.RS 4
.RE
.IP "\fItr\fR <in.trans.fas.gz>" 4
.IX Item "tr <in.trans.fas.gz>"
.RS 4
.IP "transcript sequence fasta file" 4
.IX Item "transcript sequence fasta file"
.RE
.RS 4
.RE
.ie n .IP "See ""\s-1DATABASE FORMAT""\s0 for more infomation." 4
.el .IP "See ``\s-1DATABASE FORMAT''\s0 for more infomation." 4
.IX Item "See DATABASE FORMAT for more infomation."
.RE
.RS 4
.RE
.IP "Optional Args :" 4
.IX Item "Optional Args :"
.RS 4
.IP "Common options :" 4
.IX Item "Common options :"
.RS 4
.IP "\fIquiet\fR" 4
.IX Item "quiet"
.RS 4
.IP "Suppress warning messege to output." 4
.IX Item "Suppress warning messege to output."
.RE
.RS 4
.RE
.IP "\fIbatch\fR [boolean]" 4
.IX Item "batch [boolean]"
.RS 4
.IP "use batch mode annotation, default in daemon mode as an annotation engine." 4
.IX Item "use batch mode annotation, default in daemon mode as an annotation engine."
.RE
.RS 4
.RE
.ie n .IP "\fIgenome\fR [ ""refgenome.fa.gz"" ]" 4
.el .IP "\fIgenome\fR [ ``refgenome.fa.gz'' ]" 4
.IX Item "genome [ refgenome.fa.gz ]"
.RS 4
.IP "reference genome fasta, bgzipped and samtools faidxed for use." 4
.IX Item "reference genome fasta, bgzipped and samtools faidxed for use."
.RE
.RS 4
.RE
.ie n .IP "\fIgenes\fR [ ""genes.list"" | geneslist_filehandle ]" 4
.el .IP "\fIgenes\fR [ ``genes.list'' | geneslist_filehandle ]" 4
.IX Item "genes [ genes.list | geneslist_filehandle ]"
.RS 4
.ie n .IP "annotate transcripts for \fIgenes\fR. e.g. {""\s-1ABC""\s0 => 1, ""\s-1DEF""\s0 => 1} or ""genes.list""" 4
.el .IP "annotate transcripts for \fIgenes\fR. e.g. {``\s-1ABC''\s0 => 1, ``\s-1DEF''\s0 => 1} or ``genes.list''" 4
.IX Item "annotate transcripts for genes. e.g. {ABC => 1, DEF => 1} or genes.list"
.RE
.RS 4
.RE
.ie n .IP "\fItrans\fR [ ""trans.list"" | translist_filehandle ]" 4
.el .IP "\fItrans\fR [ ``trans.list'' | translist_filehandle ]" 4
.IX Item "trans [ trans.list | translist_filehandle ]"
.RS 4
.ie n .IP "annotate transcripts in \fItrans\fR. e.g. {""\s-1NM_0012.1""\s0 => 1, ""\s-1NM_0034.2""\s0 => 1} or ""trans.list""" 4
.el .IP "annotate transcripts in \fItrans\fR. e.g. {``\s-1NM_0012.1''\s0 => 1, ``\s-1NM_0034.2''\s0 => 1} or ``trans.list''" 4
.IX Item "annotate transcripts in trans. e.g. {NM_0012.1 => 1, NM_0034.2 => 1} or trans.list"
.RE
.RS 4
.RE
.IP "\fImmap\fR [boolean]" 4
.IX Item "mmap [boolean]"
.RS 4
.ie n .IP "allow annotating all other non ""\s-1BEST""\s0 multiple-mapping records, boolen option, default not allowed. e.g. \s-1NM_0123.1\s0 have 3 mapping location or alternate splicing, default only the ""\s-1BEST""\s0 one will be annotated. See ""\s-1DATABASE FORMAT""\s0 for the ""\s-1BEST""\s0 definition." 4
.el .IP "allow annotating all other non ``\s-1BEST''\s0 multiple-mapping records, boolen option, default not allowed. e.g. \s-1NM_0123.1\s0 have 3 mapping location or alternate splicing, default only the ``\s-1BEST''\s0 one will be annotated. See ``\s-1DATABASE FORMAT''\s0 for the ``\s-1BEST''\s0 definition." 4
.IX Item "allow annotating all other non BEST multiple-mapping records, boolen option, default not allowed. e.g. NM_0123.1 have 3 mapping location or alternate splicing, default only the BEST one will be annotated. See DATABASE FORMAT for the BEST definition."
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Batch mode options :" 4
.IX Item "Batch mode options :"
.RS 4
.IP "\fIregion\fR [region_string]" 4
.IX Item "region [region_string]"
.RS 4
.ie n .IP "limit to only annotate transcript in \fIregion\fR. e.g. ""chr20:1234567\-1234568"", prior to \fIregbed\fR." 4
.el .IP "limit to only annotate transcript in \fIregion\fR. e.g. ``chr20:1234567\-1234568'', prior to \fIregbed\fR." 4
.IX Item "limit to only annotate transcript in region. e.g. chr20:1234567-1234568, prior to regbed."
.RE
.RS 4
.RE
.IP "\fIregbed\fR [\s-1BED\s0 format file]" 4
.IX Item "regbed [BED format file]"
.RS 4
.ie n .IP "similar to \fIregion\fR, with allowing multiple regions. e.g. ""in.region.bed""." 4
.el .IP "similar to \fIregion\fR, with allowing multiple regions. e.g. ``in.region.bed''." 4
.IX Item "similar to region, with allowing multiple regions. e.g. in.region.bed."
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Notes" 4
.IX Item "Notes"
.RS 4
.IP "Batch mode is designed for annotation of a complete list of variants on same chromosome, read all information of the chr into memory, and annotate all variants together in the order of chr coordinates. This mode can avoid frequent \s-1IO,\s0 brought by tabix searching, but need huge memory cost." 4
.IX Item "Batch mode is designed for annotation of a complete list of variants on same chromosome, read all information of the chr into memory, and annotate all variants together in the order of chr coordinates. This mode can avoid frequent IO, brought by tabix searching, but need huge memory cost."
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.RE
.RS 4
.RE
.IP "Returns" 4
.IX Item "Returns"
.RS 4
.ie n .IP "Annotation Engine object entry, please see ""load_anno"" for more information." 4
.el .IP "Annotation Engine object entry, please see ``load_anno'' for more information." 4
.IX Item "Annotation Engine object entry, please see load_anno for more information."
.RE
.RS 4
.RE
.PD
.SS "set methods for properties"
.IX Subsection "set methods for properties"
.Vb 6
\&    List of Properties:
\&                        set
\&    db                  o
\&    tr                  o
\&    refbuild            o
\&    genome              o
\&
\&    e.g.    : $beda\->set_refbuild($refbuild);
.Ve
.SS "write_using"
.IX Subsection "write_using"
.Vb 10
\&    About   : write the current using database information to files
\&    Usage   : $beda\->write_using( $file, $type );
\&    Args    : file gives the filename to output, and type is one of the following:
\&                g:  gene symbol list
\&                t:  transcript acc.ver list
\&                c:  the complete annotation region, in bed format,
\&                    which can be used as the variation calling region.
\&                b:  standard bed format of only exon region
\&                a:  BED format, exon region with \*(Aq+1\*(Aq annotation, 
\&                    oneline per one exon for one transcript, this
\&                    format allow redundancy exists, and not sorted by
\&                    chromosomal coordinates, but by the transcript acc.ver
\&                    and the exon number, this file is mainly for 
\&                    transcript originated statistics for only exon.
.Ve
.SS "get_cover_batch"
.IX Subsection "get_cover_batch"
.Vb 12
\&    About   : get covered region in batch mode
\&    Usage   : my $cover_href = $beda\->get_cover_batch( $chr, \e@stasto );
\&    Args    : a chromosome id, and an array ref of [ [ $start, $stop ], ... ]
\&    Returns : a hash ref of:
\&                {
\&                    "$start\-$stop" => [ 
\&                                        [ $tid, $left_cPos, $right_cPos ], ... 
\&                                      ], ...
\&                    # start is 1 based, to coordinate with region string format
\&                }
\&              Note: the pos\-pair which do not hit any annotation blocks, will
\&                    not exist in the returned results.
.Ve
.SS "readtr"
.IX Subsection "readtr"
.Vb 10
\&    About   : Read transcript information, and even sequences if in batch mode.
\&    Usage   : my $rtrSeqs = $beda\->readtr( genes => $rh_NewGenes, trans => $rh_NewTrans );
\&    Args    : Optional args "genes" and "trans" only accept hash ref values.
\&              if no args specified, it will load information based on the
\&              configuration of BedAnno entry.
\&    Returns : A hash ref of trSeqs:
\&              {
\&                $tr_acc => {
\&                    len      => $tr_len,
\&                    gene     => $gene_sym,
\&
\&                    # optional tags:
\&                    prot     => $prot_acc,
\&                    plen     => $prot_len,
\&                    csta     => $cds_start_on_trSeq, # 0 based
\&                    csto     => $cds_end_on_trSeq,   # 1 based
\&                    seq      => $tr_sequence,
\&                    
\&                    nfs      => { $fslead => $fsbase, ... },
\&                    cfs      => { $cfslead => $fsbase, ... },
\&                    X        => 1,                   # inseqStop
\&                    U        => 1,                   # selenocysteine
\&                    A        => 1,                   # polyATail
\&                    altstart => {                    # altstart codons
\&                        $startCodons1 => 1,
\&                        $startCodons2 => 1,
\&                        ...
\&                    },
\&
\&                    # the following two keys will be assigned
\&                    # to mRNA when needed
\&                    cseq     => $codonSequence,
\&                    pseq     => $proteinSequence,
\&                },
\&                ...
\&              }
.Ve
.SS "load_anno"
.IX Subsection "load_anno"
.Vb 10
\&    About   : load all needed annotation infomation into memory for multi\-process annotation
\&    Usage   : my $ranndb = $beda\->load_anno( region => "chr20:1234567\-1234568", trans => \e%trans );
\&    Args    : Using %args to override class\*(Aqs properties: region, regbed, genes, trans
\&              if no args, use the the class\*(Aqs properties as default.
\&    Returns : a localized merged anno db, The returned annotation database is a hash ref.
\&        {
\&            $chr => [
\&                {
\&                    sta   => $start, (0 based)
\&                    sto   => $stop,  (1 based)
\&                    annos => {
\&                        $anno_string => $offset, ...
\&                    }
\&
\&                    detail => {
\&                        $tid => {
\&                            gsym => $gsym,    (gene symbol)
\&                            gid  => $gid,     (Entrez gene id)
\&                            gpSO => $gpSO,    (GeneParts SO)
\&                            blka => $blka,    (block attribute)
\&                            exin => $exin,    (exon intron number)
\&                            nsta => $nsta,    (n./r. left  of whole block)
\&                            nsto => $nsto,    (n./r. right of whole block)
\&                            csta => $csta,    (c.    left  of whole block)
\&                            csto => $csto,    (c.    right of whole block)
\&                            wlen => $wlen,    (length of whole block)
\&                            pr   => $pr,      (primary tag)
\&                            strd => $strd,    (strand)
\&                            offset => $offset,(offset of current block to whole block)
\&                            mismatch => $mismatch (non\-equal length block descripter)
\&                        }, ...
\&                    }
\&                }, ... 
\&            ], ...
\&        }
\&      Note: when variation hit one of the annotation entry, the anno_string will be parsed.
\&      and the "detail" tag will be added then.
.Ve
.SS "region_merge"
.IX Subsection "region_merge"
.Vb 4
\&    About   : merge consecutive same\-entries regions
\&    Usage   : my $rannodb = region_merge($loaded_db);
\&    Args    : A hash ref of loaded_db.
\&    Returns : A hash ref of merged db.
.Ve
.SS "anno"
.IX Subsection "anno"
.Vb 10
\&    About   : Annotate single short variation by annotation db.
\&    Usage   : my $anno_ent = $beda\->anno( \*(Aqchr20\*(Aq, 1234567, 1234569, \*(AqAG\*(Aq, \*(AqTGGG\*(Aq );
\&              or $anno_ent = $beda\->anno( \*(Aqchr20\*(Aq, 1234568, \*(AqAG\*(Aq, \*(AqAGGG\*(Aq );
\&    Args    : for CG\*(Aqs shell variants, need 5 args in UCSC coordinates
\&              (0\-based start), they are:
\&                chr id, chr start, chr end, reference, alternative.
\&              for variants in VCF, need 4 args, which is lack of 
\&                chr end, and "chr start" is in 1\-based coordinates.
\&              for crawler: a input object with keys: 
\&                chr,begin,referenceSequence,variantSequence,[end].
\&                if end is specified, then use 0\-based coordinates,
\&                otherwise 1\-based (VCF) coordinates will be used.
\&    Returns : a hash ref of annotation informations, see varanno().
.Ve
.SS "varanno"
.IX Subsection "varanno"
.Vb 8
\&    About   : implicitly create a new BedAnno::Anno entry, and 
\&              assign all the needed annotation for to it.
\&    Usage   : ($rAnnoRst, $AEIndex) = $beda\->varanno($var, $AEIndex);
\&    Args    : The BedAnno entry, BedAnno::Var entry and current dbidx, 
\&              current dbidx should be always 0, if used for non\-batch mode.
\&    Returns : A BedAnno::Anno entry and current dbidx for nex query in batch.
\&            {
\&                var => {
\&
\&                    # the first part is from var parsing result.
\&                    # please see "BedAnno::Var new()".
\&                    # import all the keys from original parsed var entry
\&                    # and add the following keys by this method.
\&
\&                    varName => $var_mutation_name,
\&
\&                    # information
\&                    varTypeSO => $varTypeSO,
\&                    gHGVS     => $gHGVS,
\&                    refbuild  => $referenceBuild,
\&                },
\&                trInfo => {
\&                    $tid => {
\&                        trVarName     => $transcriptVariantName,
\&                        geneId        => $Entrez_Gene_ID,
\&                        geneSym       => $Gene_Symbol,
\&                        prot          => $Protein_Acc_Ver,
\&                        strd          => $strand,
\&                        rnaBegin      => $Begin_in_RNA_transcript,
\&                        rnaEnd        => $End_in_RNA_transcript,
\&                        cdsBegin      => $Begin_in_CDS,            # cDot format
\&                        cdsEnd        => $End_in_CDS,              # cDot format
\&                        protBegin     => $Begin_in_Protein,
\&                        protEnd       => $End_in_Protein,
\&                        c             => $cHGVS,
\&                        p             => $pHGVS,
\&                        p3                => $threeletter_pHGVS,
\&                        cc            => $codon_change,
\&                        polar         => $polar_change,
\&                        r             => $imp_funcRegion,
\&                        r_Begin       => $imp_beginfuncRegion,
\&                        r_End         => $imp_endfuncRegion,
\&                        func          => $imp_funcCode,
\&                        exin          => $exIntr_number,
\&                        ei_Begin      => $imp_Begin_exIntr_number,
\&                        ei_End        => $imp_End_exIntr_number,
\&                        genepart      => $GenePart,
\&                        genepartSO    => $GenePartSO,
\&                        componentIndex => $componentIndex,
\&                        exonIndex     => $exonIndex,               # \*(Aq.\*(Aq for N/A
\&                        intronIndex   => $intronIndex,             # \*(Aq.\*(Aq for N/A
\&                        funcSOname    => $FunctionImpact,
\&                        funcSO        => $FunctionImpactSO,
\&                        trAlt         => $alt_string_on_transcript,
\&                        trRef         => $ref_string_on_transcript,
\&                        prAlt         => $protein_alt_sequence,
\&                        prRef         => $protein_ref_sequence,
\&                        primaryTag    => $refstandard_primary_or_not,   # Y/N
\&                        preStart => {    # the position before the start of var
\&                            nDot => $rna_hgvs_pos,
\&                            cDot => $cds_hgvs_pos,
\&                            r    => $func_region,
\&                            exin => $exon_intron_number,
\&                        },
\&                        postEnd => {     # the position after the end of var
\&                            nDot => $rna_hgvs_pos,
\&                            cDot => $cds_hgvs_pos,
\&                            r    => $func_region,
\&                            exin => $exon_intron_number,
\&                        },
\&                        trRefComp => {
\&
\&                            # some trRef components
\&                        },
\&
\&                        # for some of splice variants, there may exists 
\&                        # the following function information
\&                        alt_func        => $alternative_func_code,
\&                        alt_funcSO      => $alternative_variant_SO_id,
\&                        alt_funcSOname  => $alt_variant_SO_name,
\&                    },
\&                    ...
\&                }
\&            }
.Ve
.SS "P1toP3"
.IX Subsection "P1toP3"
.Vb 2
\&    About : Change 1 letter format of pHGVS string to 3 letter format
\&    Usage : my $p3 = P1toP3($p1);
.Ve
.SS "finaliseAnno"
.IX Subsection "finaliseAnno"
.Vb 7
\&    About   : finalise the BedAnno::Anno entry by check all tag values,
\&              and uniform them for AE output usage, query transcript
\&              oringinated additional resources and add them into the data
\&              frame.
\&    Usage   : $beda\->finaliseAnno($annEnt);
\&    Args    : BedAnno entry and a BedAnno::Anno entry
\&    Returns : A finalised BedAnno::Anno entry
.Ve
.SS "decide_major"
.IX Subsection "decide_major"
.Vb 10
\&    About   : In finalise step, decide a major transcript to report for a var.
\&    Usage   : my $majorTranscriptVarName = decide_major($annoEnt);
\&    Returns : A string in the following format:
\&              If the transcript has a pName: 
\&                  mrnaAcc(geneSymbol): cName (pName), 
\&                  e.g. NM_145651.2(SCGB1C1): c.13C>T (p.R5C)
\&              If the transcript does not have a pName: 
\&                  mrnaAcc(geneSymbol): cName
\&              If only intergenic
\&                  chr: gName (intergenic)
\&                  e.g. chrX: g.220025A>T (intergenic)
\&    Note    : use the primaryTag to find reference standard or primary transcript,
\&              if only one have the primaryTag "Y", then use it,
\&              otherwise, sort by GenePart: 
\&                1.  CDS
\&                2.  span
\&                3.  five_prime_cis_splice_site
\&                4.  three_prime_cis_splice_site
\&                5.  ncRNA
\&                6.  five_prime_UTR
\&                7.  three_prime_UTR
\&                8.  interior_intron
\&                9.  five_prime_UTR_intron
\&                10. three_prime_UTR_intron
\&                11. abnormal\-intron
\&                12. promoter
\&                13. annotation\-fail
\&                14. intergenic_region
\&              and choose the first one, if more than one transcript have the 
\&              same reference standard and same GenePart, then choose the first
\&              one which prior in name sorting.
.Ve
.SS "getTrChange"
.IX Subsection "getTrChange"
.Vb 5
\&    About   : Calculate the transcript changes, based on TrPostition
\&    Usage   : $beda\->getTrChange($annoEnt);
\&    Returns : assign the following tags in annoEnt
\&                trRef, prot, c, p, cc, polar, func
\&                prRef, prAlt
.Ve
.SS "prWalker"
.IX Subsection "prWalker"
.Vb 7
\&    About   : act as trWalker, but on protein sequence
\&    Usage   : $prVar = $beda\->prWalker( $prSeq,  $prBegin, $prEnd, $prRef, $prAlt );
\&    Args    : prSeq   \- whole protein sequence
\&              prBegin \- protein variant Begin position (1 based)
\&              prEnd   \- protein variant End position (1 based)
\&              prRef   \- protein variant reference sequence
\&              prAlt   \- protein variant alt sequence
.Ve
.SS "trWalker"
.IX Subsection "trWalker"
.Vb 10
\&    About   : walk around the variant position to find possible
\&              repeat start/end, and return the recalculated
\&              trBegin and trEnd, together with the real
\&              transcript originated variants and unified property
\&              Current implementation won\*(Aqt walk around in the following
\&              cases:
\&              1. no\-call
\&              2. annotation\-fail
\&              3. snv or mnp
\&              4. non\-exon region
\&              5. span case or any edge case
\&              6. delins without repeat.
\&    Usage   : ($trBegin, $trEnd, $real_var) = 
\&              $beda\->trWalker($tid, $rtrinfo);
\&    Args    : trAcc and hash ref of trInfo annotation for trAcc,
.Ve
.SS "cmpPos"
.IX Subsection "cmpPos"
.Vb 5
\&    About   : judge the order for p1 and p2, because the insertion
\&              will have a reverted order of left & right position
\&    Usage   : my $cmpRst = BedAnno\->cmpPos($p1, $p2);
\&    Args    : hgvs positio p1 and p2, with out \*(Aqc.\*(Aq or \*(Aqn.\*(Aq flag
\&    Return  : 0 for same, 1 for normal order, \-1 for reversed order.
.Ve
.SS "_getCPosFrame_by_cdsPos"
.IX Subsection "_getCPosFrame_by_cdsPos"
.Vb 8
\&    About   : calculate codon position and frame info by
\&              involving frameshift case in consideration.
\&    Usage   : my @cPosFrame = _getCPosFrame_by_cdsPos( $trdbEnt, $cds_p );
\&    Args    : cds_p is relative position to the first bp in start codon on trans
\&    Returns : an array in the format of:
\&              ( $stat, $ra_posrefs1, $ra_posrefs2 )
\&              ra_posrefs* is an array ref for the following array
\&              [ $codonPos, $frame ]
\&
\&              for non\-cds region case stat is \-1, without ra_posrefs.
\&              for normal case stat is 1, 
\&                  ra_posrefs1 is the information of input position,
\&                  without ra_posrefs2 specified.
\&              for deleted frame case stat is 0,
\&                  ra_posrefs1 is the information of position on 5\*(Aq 
\&                  side next to the deleted frame, and ra_posrefs2
\&                  is on 3\*(Aq side.
\&              for duplicated frame case stat is 2,
\&                  ra_posrefs1 is the 5\*(Aq most hit of input position,
\&                  ra_posrefs2 is the corresponding position on the 
\&                  3\*(Aq duplicated region.
.Ve
.SS "_cdsubstr"
.IX Subsection "_cdsubstr"
.Vb 9
\&    About   : substr from transcript seqeunce involving frameshift changing.
\&    Usage   : my $codonStr = _cdsubstr( $trdbEnt, $start, $length, $replace );
\&    Args    : trdbEnt is a sub hash in trInfodb which contains csta, csto.
\&              start is 0 based start position of sub string on transcript seq.
\&              length is the length of target region on transcript seq.
\&              replace is the alternative.
\&    Returns : A substring cut from the transcript sequence, with frameshift involved.
\&              Behave like function "substr", but for replace mode, 
\&              it returns the whole transcript seq after replacement.
.Ve
.SS "_getPairedCodon"
.IX Subsection "_getPairedCodon"
.Vb 10
\&    About   : get codon position, codon string, aa string, and frame info
\&              for a pair of transcript position
\&    Usage   : my ($rcinfo5, $rcinfo3) = _getPairedCodon( $trdbEnt, $p5, $p3 );
\&    Args    : trdbEnt is a sub hash in trInfodb which contains csta, csto
\&              for cds start/end position, besides many other feature tags.
\&              p5 and p3 is a pair of positions which give a region or single
\&              position or maybe an insertion anchor.
\&    Returns : codon info array ref for p5 and p3. The array ref:
\&              [
\&                  AA position  \- 0 for not in cds region.
\&                  codon string \- codon string, e.g. "ATA".
\&                  aa char      \- AA code, 1 bp mode, e.g. "E".
\&                  polar        \- Polar properties, e.g. "P+".
\&                  frame        \- current position\*(Aqs frame info,
\&                                 \-1 for not available or in fs\-site.
\&                  [frame\-alt]  \- frame info around fs\-site.
\&              ]
.Ve
.SS "translate"
.IX Subsection "translate"
.Vb 11
\&    About   : Translate nucleotides to aa seqs
\&    Usage   : my ($aa_seq, $next_frame) = translate( $nucl, { mito => 1, polyA => 1 } );
\&    Args    : first args should be the nucleotide seq to be translated,
\&              the second args is a hash ref of optional args (all boolean):
\&              mito   : indicate it is for mDNA (mitochondrion)
\&              nostop : indicate there\*(Aqs no stop codon in aa seq,
\&                       translate \*(AqUGA\*(Aq to \*(AqU\*(Aq, and other stop codon to \*(AqX\*(Aq
\&              polyA  : indicate extra A should be added to 3\*(Aqend of codon,
\&                       to help encode a stop codon (usually used with mito).
\&    Returns : $aa_seq is the aa sequence, 
\&              $next_frame gives the next base\*(Aqs frame to the 3\*(Aqend of sequence.
.Ve
.SS "getTrRef"
.IX Subsection "getTrRef"
.Vb 10
\&    About   : generate concatenated transcript originated reference
\&    Usage   : my $trRef = getTrRef( $trannoEnt, $refgenome, $trSeq, $strd );
\&    Args    : trannoEnt \- BedAnno::Anno\->{trInfo}\->{$tid}
\&              refgenome \- Unified reference in BedAnno::Var
\&              trSeq     \- whole transcript
\&              strd      \- strand of transcript.
\&    Returns : transcript originated reference
\&    Notes   : Using sequence from transcript as the exon part,
\&              and using the sequence from reference genome
\&              as the intron part. and concatenate them.
.Ve
.SS "batch_anno"
.IX Subsection "batch_anno"
.Vb 7
\&    About   : The fastest way to annotate multiple snv and 1bp deletion variations,
\&              indel and other types also can be annotated, but no faster than annotated
\&              one by one.
\&    Usage   : $beda = BedAnno\->new( db => \*(Aqin.bed.gz\*(Aq, tr => \*(Aqin.trans.fas\*(Aq, batch => 1);
\&              $rAnnoRst = $beda\->batch_anno($rVars);
\&    Args    : an array ref of BedAnno::Var entries.
\&    Returns : an array ref of BedAnno::Anno entries, see varanno().
.Ve
.SH "BedAnno::Var"
.IX Header "BedAnno::Var"
.Vb 1
\&    BedAnno::Var sub module
.Ve
.SH "METHOD"
.IX Header "METHOD"
.SS "new"
.IX Subsection "new"
.Vb 10
\&    About   : Create a new object class entry, BedAnno::Var,
\&              parse the variation directly by the ref and alt string.
\&    Usage   : my $var = BedAnno::Var\->new( $chr, $start, $end, $ref, $alt );
\&           or my $var = BedAnno::Var\->new( $chr, $pos, $ref, $alt );
\&           or my $var = BedAnno::Var\->new( $varInput );
\&    Args    : Input can be variable format
\&              1. 5 parameters format: CG shell list format: chr,start,end,ref,alt
\&              2. 4 parameters format: VCF format: chr,pos,ref,alt
\&              3. Crawler input object: A hash ref with nessesary keys: 
\&                 chr,begin,referenceSequence,variantSequence,  
\&                 optional key is "end", if end specified,
\&                 coordinates are treat as 0\-based, otherwise, use 1\-based (VCF)
\&    Returns : a new BedAnno::Var entry :
\&            {
\&                chr    => $chr,
\&                pos    => $start,          # 0\-based start
\&                end    => $end,
\&                ref    => $ref,
\&                alt    => $alt,
\&                reflen => $ref_len,
\&                altlen => $alt_len,        # not exists if no\-call
\&                guess  => $varType,        # the output varType
\&                imp    => $imp_varType,    # the implicit varType
\&                sm     => $sm,             # single/multiple base indicator
\&                                           # equal/non\-equal length indicator
\&
\&                # for hgvs naming convinient, reparse delins(guess),
\&                # in forward and reverse strand separately,
\&                # If the result are the same, then only
\&                # give the following optional
\&                # rescaled strand\-same description group
\&                bp  => $bc_pos,       # backward compatible pos, 0\-based
\&                br  => $bc_ref,       # backward compatible ref string
\&                ba  => $bc_alt,       # backward compatible alt string
\&                brl => $bc_reflen,    # backward compatible ref length
\&                bal => $bc_altlen,    # backward compatible alt length
\&
\&                # otherwise, the following \*(Aq+\*(Aq, \*(Aq\-\*(Aq,
\&                # structure will be generated to reflect
\&                # the difference. they are all optional
\&
\&                \*(Aq+\*(Aq => {
\&
\&                  # This group simplely trim off the leading same chars
\&                  # on forward strand, and then trim the same tail
\&                  bp  => $backward_fpos,
\&                  br  => $backward_fref,
\&                  ba  => $backward_falt,
\&                  brl => $backward_freflen,
\&                  bal => $backward_faltlen,
\&
\&                },
\&
\&                \*(Aq\-\*(Aq => { 
\&                  # similar to \*(Aq+\*(Aq, but for reverse strand 
\&                },
\&
\&                # this group gives ref/alt string based on the rule
\&                # with \*(Aqrep\*(Aq annotation available
\&                p      => $rep_left_pos,         # repeat pos, 0\-based
\&                r      => $rep_ref,              # repeat ref string
\&                a      => $rep_alt,              # repeat alt string
\&                rl     => $rep_reflen,           # repeat ref length
\&                al     => $rep_altlen,           # repeat alt length
\&                rep    => $repeat_element,
\&                replen => $repeat_element_length,
\&                ref_cn => $copy_number_in_ref,
\&                alt_cn => $copy_number_in_alt,
\&
\&                # for equal length long substitution
\&                # record the separated snvs positions
\&                # all positions are 1 based.
\&                sep_snvs => [ $snv_pos1, $snv_pos2, ... ],
\&            }
.Ve
.SS "getUnifiedVar"
.IX Subsection "getUnifiedVar"
.Vb 10
\&    About   : uniform the pos and ref/alt pair selection,
\&              after new(), give info for HGVS naming.
\&    Usage   : my @unified_desc = $var\->getUnifiedVar($strd);
\&    Args    : BedAnno::Var entry and current strand for annotation.
\&    Returns : an array of ( 
\&                $pos,  # 0\-based start pos
\&                $ref,  # reference bases
\&                $alt,  # called bases
\&                $reflen, # reference len
\&                $altlen )# called len, undef if no\-call
.Ve
.SS "parse_complex"
.IX Subsection "parse_complex"
.Vb 6
\&    About   : parse complex delins variants to recognize 
\&              repeat and differ strand\-pos var.
\&    Usage   : my $var = $var\->parse_complex();
\&    Args    : variantion entry, which have been uniform to 
\&              CG\*(Aqs shell list format, with its \*(Aqguess\*(Aq:delins.
\&    Returns : see BedAnno::Var\->new()
.Ve
.SS "guess_type"
.IX Subsection "guess_type"
.Vb 12
\&    About   : guess the varType directly from the input information.
\&    Usage   : my ($guess, $implicit_varType, $sm) = guess_type($len_ref, $ref, $alt);
\&    Args    : 1. length of reference (derived from end \- start)
\&              2. reference sequence (\*(Aq.\*(Aq or empty for ins )
\&              3. called sequence ( \*(Aq?\*(Aq for no\-call, \*(Aq.\*(Aq or empty for del )
\&    Returns : $guess is varType in output (ref,snv,ins,del,delins,no\-call)
\&              $implicit_varType (ref,snv,ins,del,delins,rep)
\&              $sm is single/multiple/equal/non\-equal\-len indicator
\&                0 \- ins case
\&                1 \- single base ref case
\&                2 \- multiple base, different length case
\&                3 \- multiple base, equal length case
.Ve
.SS "get_internal"
.IX Subsection "get_internal"
.Vb 12
\&    About   : recalculate ref alt for delins and mutiple sample caused ref\-alt pair.
\&              depend on different strand of the to\-annotated gene or transcript, 
\&              the offset may be different for the same ref and alt,
\&              because of the 3\*(Aqend nearest annotation rules.
\&    Usage   : my $rephase = get_internal( $ref, $reflen, $alt, $altlen );
\&    Returns : a hash ref of : 
\&                {
\&                    \*(Aq+\*(Aq => $f_lofs,
\&                    \*(Aq\-\*(Aq => $r_lofs,
\&                    \*(Aqr\*(Aq => $new_ref_len, 
\&                    \*(Aqa\*(Aq => $new_alt_len
\&                }
.Ve
.SS "get_gHGVS"
.IX Subsection "get_gHGVS"
.Vb 4
\&    About   : get genomic (chromosomal) HGVS string of variation
\&    Usage   : my $gHGVS = $var\->get_gHGVS();
\&    Args    : variation entry, after BedAnno::Var\->new().
\&    Returns : chromosomal HGVS string.
.Ve
.SH "BedAnno::Anno"
.IX Header "BedAnno::Anno"
.Vb 1
\&    BedAnno::Anno sub package
.Ve
.SH "METHOD"
.IX Header "METHOD"
.SS "new"
.IX Subsection "new"
.Vb 4
\&    About   : Create BedAnno::Anno object
\&    Usage   : my $annoEnt = BedAnno::Anno\->new($var);
\&    Args    : BedAnno::Var entry
\&    Returns : BedAnno::Anno entry
.Ve
.SS "getTrPosition"
.IX Subsection "getTrPosition"
.Vb 12
\&    About   : Assign the BedAnno::Anno obj\*(Aqs trInfo with affected regions
\&    Usage   : my $AEIndex = $annoEnt\->getTrPosition($rannodb, $AEIndex);
\&    Args    : $rannodb is a chromosome branch of BedAnno object\*(Aqs annodb feature,
\&              $AEIndex is the current index for annodb searching.
\&    Returns : A new AEIndex for next query.
\&    Notes   : $AEIndex is used for same chr batch mode.
\&              assign the following tag to $annoEnt
\&              {
\&                trInfo => {
\&                    $tid => {
\&                        geneId,   geneSym, strd, primaryTag,
\&                        trAlt => $stranded_alt_string_with_ext_at_mismatches,
\&
\&                        preStart => {
\&                            nDot, cDot, exin, r
\&                        },
\&
\&                        postEnd => {
\&                            nDot, cDot, exin, r
\&                        },
\&
\&                        trRefComp => {
\&                            $exon_number   => $transcript_exon_length,
\&                            $intron_number => [
\&                                $start_in_non_stranded_reference,
\&                                $stop_in_non_stranded_reference
\&                              ],
\&                            ...
\&                        },
\&                    },
\&                    ...
\&                }
\&              }
.Ve
.SS "cal_hgvs_pos"
.IX Subsection "cal_hgvs_pos"
.Vb 10
\&    About   : calculate nDot, cDot HGVS position, depend on given offset,
\&              assign trAlt string and nDot HGVS and cDot HGVS positions.
\&    Usage   : $annoEnt\->cal_hgvs_pos(
\&                    offset => $offset, 
\&                    tid    => $tid,
\&                    LR     => $lr,
\&                    tidDetail => $rh_tidDetail,
\&              );
\&    Args    : ofst is total offset to the start(left) of currunt annoblk,
\&              tid is the transcript id for the detail entry
\&              tidDetail is the currunt annoblk detail
\&              LR indicate this offset is left or right pos,
\&                1 for left and assign sta group,
\&                0 for right and assign end group.
\&              "noassign" to indicate whether to assign those information
\&              to annoEnt, it\*(Aqs used return the useful information only,
\&              without change the annoEnt. 
\&    Returns : if noassign is used, then return a hash ref, which contains
\&                { nDot, cDot, exin, r } if successful.
\&              otherwise, 0 for no assigned status, 1 for successful assigned.
\&             
\&    Notes   : For position mirror on transcript, there are 2 other cases 
\&              than normal case:
\&              1. annotation fail, which can not be annotated in the region
\&                 of it, the bad alignment string start with \*(AqE\*(Aq.
\&              2. block with length changing mismatches, or long substitution
\&                 mismatch, which contain the following three cases:
\&                 
\&                 a. insertion (I) on refSeq
\&
\&                        +\-\-\-\-\-\-\-+\-\-\-+\-\-\-\-\-\-\-\-+  refgenome
\&                         \e       \e /        /
\&                          +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+    refSeq
\&
\&                 b. deletion (D) on refSeq 
\&
\&                          +\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+    refgenome
\&                         /       / \e        \e
\&                        +\-\-\-\-\-\-\-+\-\-\-+\-\-\-\-\-\-\-\-+  refSeq
\&
\&                 c. delins (S/DI) on refSeq (equal/non\-equal length)
\&
\&                        +\-\-\-\-\-\-\-+\-\-\-+\-\-\-\-\-\-\-\-+  refgenome
\&                        |       |  /        /
\&                        +\-\-\-\-\-\-\-+\-+\-\-\-\-\-\-\-\-+    refSeq
\&
\&                 Insertion will have an reversed start/end position on refSeq,
\&                 due to the 1\-based position description system.
\&                 
\&                 Any position located in a non\-zero length refgenome mismatch
\&                 block have to extend to total region of mismatched block,
\&                 and alternate "trAlt" value in annotation entry for this tid.
\&
\&              This method assign the following tag to $annoEnt
\&                {
\&                    trInfo => {
\&                        $tid => {
\&                            rnaBegin, rnaEnd,  cdsBegin, cdsEnd,
\&                            ei_Begin, ei_End,  r_Begin,  r_End,
\&                            genepartSO, trAlt,
\&                          },
\&                        ...
\&                    }
\&                }
.Ve
.SH "BedAnno::CNV"
.IX Header "BedAnno::CNV"
.Vb 1
\&    BedAnno::CNV sub package
.Ve
.SH "METHOD"
.IX Header "METHOD"
.SS "new"
.IX Subsection "new"
.Vb 10
\&    About   : Create BedAnno::CNV object
\&    Usage   : my $cnva = BedAnno::CNV\->new( db => $annodb, tr => $trdb, dgv => $dgvdb, cnvPub => $cnvPubdb );
\&    Args    : required args: db, tr
\&              Specific args:
\&                \- ovlp_rate   overlapping region rate while searching for hits
\&                \- max_uncov   maximum uncovered region length in querys while searching.
\&                \- dgv         DGV tabix index file as Controls (got from anno_dgv)
\&                \- sfari       SFARI tabix index file, as a case/control mix resource for autism.
\&                \- cnvPub      Well formatted tabix indexed file as a collection of Cases
\&                \- cnvd        CNVD database tabix indexed file.
\&              Same args in BedAnno method \*(Aqnew\*(Aq:
\&                \- db, tr, genes, trans, region, regbed, mmap, batch
\&    Returns : BedAnno::CNV object
.Ve
.SS "annoCNV"
.IX Subsection "annoCNV"
.Vb 9
\&    About   : Annotate single CNV variants
\&    Usage   : my $rcnvAnno = $cnva\->annoCNV( $chr, $start, $end, $copy_number );
\&    Args    : $chr   \- chromosome number
\&              $start \- 0 based start position
\&              $end   \- 1 based end position
\&              $copy_number \- estimated copy number
\&    Returns : A hash ref of cnv annotation in the following structure
\&                {
\&                    cnva_type => $cnv_anno_type,
\&
\&                    # if hit on transcript
\&                    anno => {
\&                        $tid => {
\&                            gsym   => $gene_symbol,
\&                            gid    => $gene_id,
\&                            strd   => $strand,
\&                            cpos   => $hgvs_position,
\&                            exin   => $exon_intron_number,
\&                            regcod => $code_of_region,
\&                            regtyp => $type_of_region,
\&                        },
\&                        ...
\&                    },
\&
\&                    # available when resource ok
\&                    cytoBand  => $cytoBand_info,
\&                    dgv    => $dgv_sql_rst,
\&                    sfari  => $sfari_sql_rst,
\&                    cnvd   => $cnvd_sql_rst,
\&                    cnvPub => $cnvPub_sql_rst,
\&                }
.Ve
.SS "batch_annoCNV"
.IX Subsection "batch_annoCNV"
.Vb 10
\&    About   : Annotate CNV variants in batch mode
\&    Usage   : my $rcnvAnnos = $cnva\->batch_annoCNV( $ref_hash_AllCNV );
\&    Args    : A hash ref of all cnv annotation in the following structure
\&                {
\&                    $chr => {
\&                        "$start\-$stop" => $copy_number, 
\&                        # start is 1 based, to coordinate with region string format
\&                        ...
\&                      },
\&                      ...
\&                }
\&    Returns : A hash ref of annotated cnv variants in the following structure
\&                {
\&                    $chr => {
\&                        "$start\-$stop" => {
\&                           cnva_type => $cnv_anno_type,
\&                           
\&                           # if hit on transcript
\&                           anno => {
\&                             $tid => {
\&                               gsym => $gene_symbol,
\&                               gid  => $gene_id,
\&                               strd => $strand,
\&                               cpos => $hgvs_position,
\&                               exin => $exon_intron_number,
\&                               regcod => $code_of_region,
\&                               regtyp => $type_of_region,
\&                             },
\&                             ...
\&                           },
\&
\&                           # available when resource ok
\&                           cytoBand  => $cytoBand_info,
\&                           dgv => $dgv_sql_rst,
\&                           cnvPub => $cnvPub_sql_rst,
\&                        },
\&                        ...
\&                      },
\&                      ...
\&                }
.Ve
.SH "DATABASE FORMAT"
.IX Header "DATABASE FORMAT"
The Format of annotation database is listed as following:
.SS "\s-1BED FORMAT DATABASE\s0"
.IX Subsection "BED FORMAT DATABASE"
.Vb 2
\&   Departed block with tag for annotation, Tag entries are separated by "; ",
\&   and Infos items in entry are separated by "|".
\&
\&   Each entry contains the follwing infomation:
\&
\&   1. Acc.Ver
\&   2. GeneID
\&   3. Gene Symbol
\&   4. Strand
\&                 5\*(Aq=====|>>>|[=============]|>>>>>>|[==========]|>>>>>>|[=============]|>>>>|==3\*(Aq
\&   5. BlockAttr  : PROM 5U2E D5U1 I5U1 A5U1 5U1 C1  DC1 IC1 AC1 C2E 3U1 D3U1 I3U1 A3U1 3U2E
\&   6. GenePartsSO: 167  204  163  447  164  204 316 163 191 164 316 205 163  448  164  448
\&   7. ExIn Num   :    . |EX1|      IVS1     |  EX2 |    IVS2    |  EX3 |    IVS3       |EX4E|
\&   8. nHGVS start for block before departing
\&   9. nHGVS end for block before departing
\&   10.cHGVS start for block before departing
\&   11.cHGVS end for block before departing
\&   12.Length for block before departing
\&   13.MismatchBlock :  $type,$gstart,$gstop,$gseq
\&                       ($gseq is in the strand of refseq, \*(Aq.\*(Aq for deletion)
\&   14.Primary Tag : Please see "PRIMARY TAG ASSIGNMENT"
\&   15.Offset to leftmost of non departing block.
.Ve
.SS "\s-1TRANSCRIPT FASTA DATABASE\s0"
.IX Subsection "TRANSCRIPT FASTA DATABASE"
.Vb 3
\&   One\-line sequence fasta file
\&   ============================
\&   Header format is: ( separate by " ", with "." for unavailable value )
\&
\&       >rnaAcc.ver rnaLen gene protAcc.ver protLen cdsSta,cdsEnd tags [altStartCodons] [frameshiftSite]
\&   
\&    "tags" are a string of multiple properties separated by "|", which are:
\&
\&        <alignStat>[|altstart][|selenocysteine][|inseqStop][|polyATail]
\&
\&    when "tags" contain "altstart", alternative start codons will be list in 
\&    "altStartCodons", separated by ";"
.Ve
.SS "\s-1PRIMARY TAG ASSIGNMENT\s0"
.IX Subsection "PRIMARY TAG ASSIGNMENT"
.Vb 2
\&    Our database need to sort the refSeq record with same Acc, 
\&    or with same gene by the following rules:
\&
\&    1. whether the transcript is on the primary assembly.
\&    2. whether the CDS is 3\-codons (badcds will be put to the tail)
\&    3. concatenated CDS is longer
\&    4. concatenated Exon is longer
\&    5. union Exon with flank region is longer
\&    6. Chromosome ID number is smaller
\&    7. Position number on forward strand\-chromosome is smaller
\&
\&    if LRG_RefSeqGene file is used, then the primary tag "Y" will
\&    only assign to the reference standard transcripts\*(Aqs first 
\&    mapping entry. But for non\-RefSeqGene gene/transcript,
\&    assign primary tag "Y" to the first record for same genes\*(Aq all
\&    transcripts, which is the same with no LRG_RefSeqGene file case.
\&
\&    For multiple\-mapping of a same transcript, add postfix "\-N" 
\&    (1..n\-1) to the other records in the order of sort.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&    HGVS     :  http://www.hgvs.org/mutnomen/recs.html
\&    Mutalyzer:  https://mutalyzer.nl
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
liutao <liut@geneplus.org.cn>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Please check \s-1LICENSE\s0 file for detail
